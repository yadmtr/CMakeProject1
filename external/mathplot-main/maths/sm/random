// -*- C++ -*-
/*!
 * This file is part of sebsjames/maths, a library of maths code for modern C++
 *
 * See https://github.com/sebsjames/maths
 *
 * \file random
 *
 * Random numbers in the sm namespace, wrapping C++ <random> stuff, with a particular
 * favouring for mt19937 and mt19937_64, the 32 and 64 bit Mersenne Twister
 * algorithms. With these classes, generate random numbers using our choice of
 * algorithms from std::random. In future, I'd like to include a siderand approach to
 * collecting entropy.
 *
 * Note on choice of mt19937 vs mt19937_64 as the 'E' template parameter: the 64 bit
 * version is slower, but is suitable if you want to generate random numbers where the
 * repeat of the sequence occurs only after as long a time as possible.
 *
 * Possible values for E:
 *
 * std::mt19937, std::mt19937_64: 32 and 64 bit Mersenne Twister (MT). 32 bit MT seems
 * to be the fastest engine! std::mt19937_64 takes twice the time.
 *
 * std::minstd_rand: linear congruential engine. 'new minimum standard' recommended by
 * Park, Miller, and Stockmeyer in 1993. The linear congruential engine is moderately
 * fast and has a very small storage requirement for state. I found it no faster than
 * std::mt19937 in one test.
 *
 * std::ranlux24, std::ranlux48: subtract-with-carry engine (aka lagged
 * Fibonacci). Seems very slow - ranlux48 is about 20 times slower than mt19937.
 *
 * std::knuth_b: A shuffle order engine. Quite slow.
 *
 * I've wrapped a selection of distributions, including normal, lognormal, poisson and
 * uniform. Copy the classes here to add additional ones that you might need from the
 * full list: https://en.cppreference.com/w/cpp/numeric/random (such as weibull or
 * exponential).
 *
 * See tests/testRandom.cpp for a variety of usage examples. Here is a single, simple
 * example:
 *
 * \code
 * #include <sm/random.h>
 * sm::randuniform<double, std::mt19937_64> randDouble;
 * double sample = randDouble.get();
 * double sample2 = randDouble.get();
 * \endcode
 *
 * A final note: There are some faster RNG algorithms on the
 * block. Xoroshiro/Xoshiro/Xorshift and SplitMix64. These don't appear to be in the c++
 * standard as yet, but they're short and could probably be implemented easily here,
 * another day.
 */
#pragma once

#include <random>
#include <vector>
#include <limits>
#include <type_traits>
#include <string>
#include <ostream>
#include <array>
#include <cstddef>
#include <memory>
#include <sm/mathconst>

namespace sm
{
    // Note that I considered having a Random<T> base class, but because the
    // distribution object isn't sub-classed, then hardly any code would be
    // de-duplicated. max(), min() and get() methods all need the dist member
    // attribute, so each one has to be written out in each wrapper class. So it goes.

    /*!
     * randuniform to be specialised depending on whether T is integral or not
     *
     * \tparam T The type of the random number to be generated
     *
     * \tparam E The pseudo-random number generator engine. See
     *  https://en.cppreference.com/w/cpp/numeric/random for options. Here, I set the
     *  Mersenne Twister algorithm as default, but beware: it comes in 32 and 64 bit
     *  versions (std::mt19937 adn std::mt19937_64). Use of the excellent 64 bit engine
     *  will slow down code which applies it to generate 32 bit numbers! So, consider
     *  providing both T and E parameters when instantiating your randuniform objects
     *  (similar for rand_normal etc, too).
     */
    template <typename T = float, typename E = std::mt19937, bool = std::is_integral<std::decay_t<T>>::value>
    class rand_uniform {};

    //! Floating-point number specialization of randUnifom.
    template <typename T, typename E> requires std::is_floating_point_v<std::decay_t<T>>
    class rand_uniform<T, E, false>
    {
    private:
        //! random device to provide a seed for the generator
        std::random_device rd{};
        //! Pseudo random number generator engine. NB: 32 bit one is faster.
        E generator{rd()};
        //std::minstd_rand generator{rd()}; // No slower than mt19937, apparently
        //! Our distribution
        std::uniform_real_distribution<T> dist;
    public:
        //! Default constructor gives RN generator which works in range [0,1)
        rand_uniform () noexcept
        {
            typename std::uniform_real_distribution<T>::param_type prms (T{0}, T{1});
            this->dist.param (prms);
        }
        //! This constructor gives RN generator which works in range [0,1) and sets a
        //! fixed seed
        rand_uniform (unsigned int _seed) noexcept
        {
            this->generator.seed (_seed);
            typename std::uniform_real_distribution<T>::param_type prms (T{0}, T{1});
            this->dist.param (prms);
        }
        //! This constructor gives RN generator which works in range [a,b)
        rand_uniform (T a, T b) noexcept
        {
            typename std::uniform_real_distribution<T>::param_type prms (a, b);
            this->dist.param (prms);
        }
        //! This constructor gives RN generator which works in range [a,b)
        rand_uniform (T a, T b, unsigned int _seed) noexcept
        {
            this->generator.seed (_seed);
            typename std::uniform_real_distribution<T>::param_type prms (a, b);
            this->dist.param (prms);
        }
        //! Copy constructor copies the parameters of the distribution
        rand_uniform (const rand_uniform<T>& rng) noexcept { this->param (rng.param()); }
        //! Copy assignment operator needs to be explicitly defined
        rand_uniform& operator= (const rand_uniform<T>& rng) noexcept
        {
            if (&rng == static_cast<const rand_uniform<T>*>(this)) { return *this; }
            this->param (rng.param());
            return *this;
        }
        //! Reveal the distribution param methods
        typename std::uniform_real_distribution<T>::param_type param() const noexcept { return dist.param(); }
        void param (const typename std::uniform_real_distribution<T>::param_type& prms) noexcept { this->dist.param(prms); }
        //! Get 1 random number from the generator
        T get() noexcept { return this->dist (this->generator); }
        //! Get n random numbers from the generator
        std::vector<T> get (std::size_t n) noexcept
        {
            std::vector<T> rtn (n, T{0});
            for (std::size_t i = 0; i < n; ++i) {
                rtn[i] = this->dist (this->generator);
            }
            return rtn;
        }
        //! Place n random numbers in the array rtn
        template<std::size_t n>
        void get (std::array<T, n>& rtn) noexcept
        {
            for (std::size_t i = 0; i < n; ++i) { rtn[i] = this->dist (this->generator); }
        }
        T min() noexcept { return this->dist.min(); }
        T max() noexcept { return this->dist.max(); }
        //! Change the max/min of the distribution to be in range [a,b)
        void setparams (T a, T b) noexcept
        {
            typename std::uniform_real_distribution<T>::param_type prms (a, b);
            this->dist.param (prms);
        }
        //! Return probability density function value, P(x)
        T prob_density ([[maybe_unused]] const T x) const noexcept
        {
            return T{1} / (this->dist.b() - this->dist.a());
        }
    };

    //! Integer specialization: Generate uniform random numbers in a integer format
    template<typename T, typename E>
    class rand_uniform<T, E, true>
    {
#ifndef __GNUC__
        static_assert (sizeof(T) > 1); // disallow single byte integers unless in gcc
#endif
    private:
        //! random device to provide a seed for the generator
        std::random_device rd{};
        //! Pseudo random number generator engine
        E generator{rd()};
        //! Our distribution
        std::uniform_int_distribution<T> dist;
    public:
        //! Default constructor gives an integer random number generator which works
        //! in range [(type min),(type max)]
        rand_uniform () noexcept
        {
            typename std::uniform_int_distribution<T>::param_type prms (std::numeric_limits<T>::min(),
                                                                        std::numeric_limits<T>::max());
            this->dist.param (prms);
        }
        //! This constructor gives an integer random number generator which works
        //! in range [(type min),(type max)] with fixed seed \a _seed.
        rand_uniform (unsigned int _seed) noexcept
        {
            this->generator.seed (_seed);
            typename std::uniform_int_distribution<T>::param_type prms (std::numeric_limits<T>::min(),
                                                                        std::numeric_limits<T>::max());
            this->dist.param (prms);
        }
        //! This constructor gives RN generator which works in range [a,b]
        rand_uniform (T a, T b) noexcept
        {
            typename std::uniform_int_distribution<T>::param_type prms (a, b);
            this->dist.param (prms);
        }
        //! This constructor gives RN generator which works in range [a,b] and sets a
        //! fixed seed.
        rand_uniform (T a, T b, unsigned int _seed) noexcept
        {
            this->generator.seed (_seed);
            typename std::uniform_int_distribution<T>::param_type prms (a, b);
            this->dist.param (prms);
        }
        //! Copy constructor copies the distribution parameters
        rand_uniform (const rand_uniform<T>& rng) noexcept { this->param (rng.param()); }
        //! Copy assignment operator needs to be explicitly defined
        rand_uniform& operator= (const rand_uniform<T>& rng) noexcept
        {
            if (&rng == static_cast<const rand_uniform<T>*>(this)) { return *this; }
            this->param (rng.param());
            return *this;
        }
        //! Reveal the distribution's param getter
        typename std::uniform_int_distribution<T>::param_type param() const noexcept { return dist.param(); }
        //! Reveal the distribution's param setter
        void param (const typename std::uniform_int_distribution<T>::param_type& prms) noexcept { this->dist.param(prms); }
        //! Get 1 random number from the generator
        T get() noexcept { return this->dist (this->generator); }
        //! Get n random numbers from the generator
        std::vector<T> get (std::size_t n) noexcept
        {
            std::vector<T> rtn (n, T{0});
            for (std::size_t i = 0; i < n; ++i) {
                rtn[i] = this->dist (this->generator);
            }
            return rtn;
        }
        //! Place n random numbers in the array rtn
        template<std::size_t n>
        void get (std::array<T, n>& rtn) noexcept
        {
            for (std::size_t i = 0; i < n; ++i) { rtn[i] = this->dist (this->generator); }
        }
        //! min wrapper
        T min() noexcept { return this->dist.min(); }
        //! max wrapper
        T max() noexcept { return this->dist.max(); }
        //! Change the max/min of the distribution to range [a,b]
        void setparams (T a, T b) noexcept
        {
            typename std::uniform_int_distribution<T>::param_type prms (a, b);
            this->dist.param (prms);
        }
        //! Return probability density function value, P(x), in floating point format
        template <typename F=float> requires std::is_floating_point_v<F>
        F prob_density ([[maybe_unused]] const T x) const noexcept
        {
            return F{1} / (this->dist.b() - this->dist.a());
        }
    };

    /*!
     * Generate numbers drawn from a random normal distribution.
     *
     * \tparam T The type of the random number to be generated
     *
     * \tparam E The pseudo-random number generator engine.
     */
    template <typename T = double, typename E = std::mt19937_64> requires std::is_floating_point_v<std::decay_t<T>>
    class rand_normal
    {
    private:
        //! random device to provide a seed for the generator
        std::random_device rd{};
        //! Pseudo random number generator engine
        E generator{rd()};
        //! Our distribution
        std::normal_distribution<T> dist;
    public:
        //! Default constructor gives RN generator with mean 0 and standard deviation 1
        rand_normal() noexcept
        {
            typename std::normal_distribution<T>::param_type prms (T{0}, T{1});
            this->dist.param (prms);
        }
        //! This constructor gives RN generator with mean 0 and standard deviation 1
        //! and set a fixed seed.
        rand_normal (unsigned int _seed) noexcept
        {
            this->generator.seed (_seed);
            typename std::normal_distribution<T>::param_type prms (T{0}, T{1});
            this->dist.param (prms);
        }
        //! This constructor gives RN generator with mean \a mean and standard deviation \a sigma
        rand_normal (T mean, T sigma) noexcept
        {
            typename std::normal_distribution<T>::param_type prms (mean, sigma);
            this->dist.param (prms);
        }
        //! This constructor gives RN generator with mean \a mean and standard deviation \a sigma
        rand_normal (T mean, T sigma, unsigned int _seed) noexcept
        {
            this->generator.seed (_seed);
            typename std::normal_distribution<T>::param_type prms (mean, sigma);
            this->dist.param (prms);
        }
        //! Copy constructor copies the distribution parameters
        rand_normal (const rand_normal<T>& rng) noexcept { this->param (rng.param()); }
        //! Copy assignment operator needs to be explicitly defined
        rand_normal& operator= (const rand_normal<T>& rng) noexcept
        {
            if (&rng == static_cast<const rand_normal<T>*>(this)) { return *this; }
            this->param (rng.param());
            return *this;
        }
        //! Reveal the distribution's param getter
        typename std::normal_distribution<T>::param_type param() const noexcept { return dist.param(); }
        //! Reveal the distribution's param setter
        void param (const typename std::normal_distribution<T>::param_type& prms) noexcept { this->dist.param(prms); }
        //! Get 1 random number from the generator
        T get() noexcept { return this->dist (this->generator); }
        //! Get n random numbers from the generator
        std::vector<T> get (std::size_t n) noexcept
        {
            std::vector<T> rtn (n, T{0});
            for (std::size_t i = 0; i < n; ++i) {
                rtn[i] = this->dist (this->generator);
            }
            return rtn;
        }
        //! Place n random numbers in the array rtn
        template<std::size_t n>
        void get (std::array<T, n>& rtn) noexcept
        {
            for (std::size_t i = 0; i < n; ++i) { rtn[i] = this->dist (this->generator); }
        }
        T min() noexcept { return this->dist.min(); }
        T max() noexcept { return this->dist.max(); }
        //! Return probability density function value, P(x)
        T prob_density (const T x) const noexcept
        {
            T sigsq = this->dist.stddev() * this->dist.stddev();
            T f1 = T{1} / std::sqrt (sm::mathconst<T>::two_pi * sigsq);
            T f2 = std::exp (-((x - this->dist.mean()) * (x - this->dist.mean()) / T{2} * sigsq));
            return f1 * f2;
        }
    };

    /*!
     * Generate numbers drawn from a random log-normal distribution.
     *
     * \tparam T The type of the random number to be generated
     *
     * \tparam E The pseudo-random number generator engine.
     */
    template <typename T = double, typename E = std::mt19937_64> requires std::is_floating_point_v<std::decay_t<T>>
    class rand_lognormal
    {
    private:
        //! random device to provide a seed for the generator
        std::random_device rd{};
        //! Pseudo random number generator engine
        E generator{rd()};
        //! Our distribution
        std::lognormal_distribution<T> dist;
    public:
        //! Default constructor gives RN generator with mean-of-the-log 0 and standard
        //! deviation-of-the-log 1
        rand_lognormal() noexcept
        {
            typename std::lognormal_distribution<T>::param_type prms (T{0}, T{1});
            this->dist.param (prms);
        }
        //! This constructor gives RN generator with mean-of-the-log 0 and standard
        //! deviation-of-the-log 1. Sets a fixed seed.
        rand_lognormal (unsigned int _seed) noexcept
        {
            this->generator.seed (_seed);
            typename std::lognormal_distribution<T>::param_type prms (T{0}, T{1});
            this->dist.param (prms);
        }
        //! This constructor gives RN generator with mean-of-the-log \a mean and
        //! standard deviation \a sigma
        rand_lognormal (T mean, T sigma) noexcept
        {
            typename std::lognormal_distribution<T>::param_type prms (mean, sigma);
            this->dist.param (prms);
        }
        //! This constructor gives RN generator with mean-of-the-log \a mean and
        //! standard deviation \a sigma and sets a seed.
        rand_lognormal (T mean, T sigma, unsigned int _seed) noexcept
        {
            this->generator.seed (_seed);
            typename std::lognormal_distribution<T>::param_type prms (mean, sigma);
            this->dist.param (prms);
        }
        //! Copy constructor copies the distribution parameters
        rand_lognormal (const rand_lognormal<T>& rng) noexcept { this->param (rng.param()); }
        //! Copy assignment operator needs to be explicitly defined
        rand_lognormal& operator= (const rand_lognormal<T>& rng) noexcept
        {
            if (&rng == static_cast<const rand_lognormal<T>*>(this)) { return *this; }
            this->param (rng.param());
            return *this;
        }
        //! Reveal the distribution's param getter
        typename std::lognormal_distribution<T>::param_type param() const noexcept { return dist.param(); }
        //! Reveal the distribution's param setter
        void param (const typename std::lognormal_distribution<T>::param_type& prms) noexcept { this->dist.param(prms); }
        //! Get 1 random number from the generator
        T get() noexcept { return this->dist (this->generator); }
        //! Get n random numbers from the generator
        std::vector<T> get (std::size_t n) noexcept
        {
            std::vector<T> rtn (n, T{0});
            for (std::size_t i = 0; i < n; ++i) {
                rtn[i] = this->dist (this->generator);
            }
            return rtn;
        }
        //! Place n random numbers in the array rtn
        template<std::size_t n>
        void get (std::array<T, n>& rtn) noexcept
        {
            for (std::size_t i = 0; i < n; ++i) { rtn[i] = this->dist (this->generator); }
        }
        T min() noexcept { return this->dist.min(); }
        T max() noexcept { return this->dist.max(); }
        //! Return probability density function value, P(x)
        T prob_density (const T x) const noexcept
        {
            T s = this->dist.s();
            T m = this->dist.m();
            T lx = std::log(x);
            T f1 = T{1} / (s * x * std::sqrt (sm::mathconst<T>::two_pi));
            T f2 = std::exp (-((lx - m) * (lx - m) / (T{2} * s * s)));
            return f1 * f2;
        }
    };

    namespace rand
    {
        // Return n!
        template <typename T, typename I>
        constexpr T factorial (const I n)
        {
            T fac = T{1};
            for (I i = I{1}; i <= n; ++i) { fac *= i; }
            return fac;
        }
    }

    /*!
     * Generate poisson random numbers in a integer format - valid Ts are short, int,
     * long, long long, unsigned short, unsigned int, unsigned long, or unsigned long
     * long.
     *
     * \tparam T The type of the random number to be generated
     *
     * \tparam E The pseudo-random number generator engine.
     */
    template <typename T = int, typename E = std::mt19937> requires std::is_integral_v<std::decay_t<T>>
    class rand_poisson
    {
    private:
        //! random device to provide a seed for the generator
        std::random_device rd{};
        //! Pseudo random number generator engine
        E generator{rd()};
        //! Our distribution
        std::poisson_distribution<T> dist;
    public:
        //! Default constructor gives a poisson random number generator with mean 0.
        rand_poisson() noexcept
        {
            typename std::poisson_distribution<T>::param_type prms (T{0});
            this->dist.param (prms);
        }
        //! Default constructor gives a poisson random number generator with mean
        //! 0. Sets fixed seed \a _seed.
        rand_poisson (unsigned int _seed) noexcept
        {
            this->generator.seed (_seed);
            typename std::poisson_distribution<T>::param_type prms (T{0});
            this->dist.param (prms);
        }
        //! This constructor gives RN generator with mean \a mean.
        template<typename F = T> requires std::is_arithmetic_v<F>
        rand_poisson (F mean) noexcept
        {
            typename std::poisson_distribution<T>::param_type prms (mean);
            this->dist.param (prms);
        }
        //! This constructor gives RN generator with mean \a mean.
        template<typename F = T> requires std::is_arithmetic_v<F>
        rand_poisson (F mean, unsigned int _seed) noexcept
        {
            this->generator.seed (_seed);
            typename std::poisson_distribution<T>::param_type prms (mean);
            this->dist.param (prms);
        }
        //! Copy constructor copies the distribution parameters
        rand_poisson (const rand_poisson<T>& rng) noexcept { this->param (rng.param()); }
        //! Copy assignment operator needs to be explicitly defined
        rand_poisson& operator= (const rand_poisson<T>& rng) noexcept
        {
            if (&rng == static_cast<const rand_poisson<T>*>(this)) { return *this; }
            this->param (rng.param());
            return *this;
        }
        //! Reveal the distribution's param getter
        typename std::poisson_distribution<T>::param_type param() const noexcept { return dist.param(); }
        //! Reveal the distribution's param setter
        void param (const typename std::poisson_distribution<T>::param_type& prms) noexcept { this->dist.param(prms); }
        //! Get 1 random number from the generator
        T get() noexcept { return this->dist (this->generator); }
        //! Get n random numbers from the generator
        std::vector<T> get (std::size_t n) noexcept
        {
            std::vector<T> rtn (n, T{0});
            for (std::size_t i = 0; i < n; ++i) {
                rtn[i] = this->dist (this->generator);
            }
            return rtn;
        }
        //! Place n random numbers in the array rtn
        template<std::size_t n>
        void get (std::array<T, n>& rtn) noexcept
        {
            for (std::size_t i = 0; i < n; ++i) { rtn[i] = this->dist (this->generator); }
        }
        //! min wrapper
        T min() noexcept { return this->dist.min(); }
        //! max wrapper
        T max() noexcept { return this->dist.max(); }
        //! Return probability density function value, P(x). As this is a discrete probability
        //! distribution, this 'probability density' will match a histogram of count proportions.
        template <typename F=float> requires std::is_floating_point_v<F>
        F prob_density (const T x) const noexcept
        {
            F m = static_cast<F>(this->dist.mean());
            F f1 = std::exp (-m) * std::pow (m, x);
            F f2 = sm::rand::factorial<F, T> (x);
            return f1 / f2;
        }
    };

    /*!
     * Generate exponentially distributed random numbers
     *
     * \tparam T The type of the random number to be generated
     *
     * \tparam E The pseudo-random number generator engine.
     */
    template <typename T = double, typename E = std::mt19937> requires std::is_floating_point_v<std::decay_t<T>>
    class rand_exponential
    {
    protected:
        //! random device to provide a seed for the generator
        std::random_device rd{};
        //! Pseudo random number generator engine
        E generator{rd()};
        //! Our distribution
        std::exponential_distribution<T> dist;
    public:
        //! Default constructor gives a exponential random number generator with rate 1 (e.g. 1 'decay per second').
        rand_exponential() noexcept
        {
            typename std::exponential_distribution<T>::param_type prms (T{1});
            this->dist.param (prms);
        }
        //! Default constructor gives a exponential random number generator with rate 1
        //! Sets fixed seed \a _seed.
        rand_exponential (unsigned int _seed) noexcept
        {
            this->generator.seed (_seed);
            typename std::exponential_distribution<T>::param_type prms (T{1});
            this->dist.param (prms);
        }
        //! This constructor gives RN generator with rate \a rate
        rand_exponential (T rate) noexcept
        {
            typename std::exponential_distribution<T>::param_type prms (rate);
            this->dist.param (prms);
        }
        //! This constructor gives RN generator with rate \a rate. and a given seed
        rand_exponential (T rate, unsigned int _seed) noexcept
        {
            this->generator.seed (_seed);
            typename std::exponential_distribution<T>::param_type prms (rate);
            this->dist.param (prms);
        }
        //! Copy constructor copies the distribution parameters
        rand_exponential (const rand_exponential<T>& rng) noexcept { this->param (rng.param()); }
        //! Copy assignment operator needs to be explicitly defined
        rand_exponential& operator= (const rand_exponential<T>& rng) noexcept
        {
            if (&rng == static_cast<const rand_exponential<T>*>(this)) { return *this; }
            this->param (rng.param());
            return *this;
        }
        //! Reveal the distribution's param getter
        typename std::exponential_distribution<T>::param_type param() const noexcept { return dist.param(); }
        //! Reveal the distribution's param setter
        void param (const typename std::exponential_distribution<T>::param_type& prms) noexcept { this->dist.param(prms); }
        //! Get 1 random number from the generator
        T get() noexcept { return this->dist (this->generator); }
        //! Get n random numbers from the generator
        std::vector<T> get (std::size_t n) noexcept
        {
            std::vector<T> rtn (n, T{0});
            for (std::size_t i = 0; i < n; ++i) {
                rtn[i] = this->dist (this->generator);
            }
            return rtn;
        }
        //! Place n random numbers in the array rtn
        template<std::size_t n>
        void get (std::array<T, n>& rtn) noexcept
        {
            for (std::size_t i = 0; i < n; ++i) { rtn[i] = this->dist (this->generator); }
        }
        //! min wrapper
        T min() noexcept { return this->dist.min(); }
        //! max wrapper
        T max() noexcept { return this->dist.max(); }
        //! Return probability density function value, P(x)
        T prob_density (const T x) const noexcept
        {
            return this->dist.lambda() * std::exp (-this->dist.lambda() * x);
        }
    };

    /*!
     * Generate random numbers from a (Type I) Pareto distribution.
     *
     * Uses exponential_distribution rng internally along with the relationship between a Type I
     * Pareto distribution, X, with minimum sigma to an exponential distribution Y: X = sigma e ^ Y
     *
     * \tparam T The type of the random number to be generated
     *
     * \tparam E The pseudo-random number generator engine.
     */
    template <typename T = double, typename E = std::mt19937> requires std::is_floating_point_v<T>
    class rand_pareto : public sm::rand_exponential<T, E>
    {
    public:
        // The minimum of the Pareto distribution, also known as the 'scale' or x_min. sigma > 0.
        T sigma = T{1};
        //! Default constructor gives a pareto random number generator with alpha 1
        //! (meaning that the underlying exponential distribution has rate 1)
        rand_pareto() noexcept
        {
            typename std::exponential_distribution<T>::param_type prms (T{1});
            this->dist.param (prms);
        }
        //! Default constructor gives a pareto random number generator with alpha (or shape) 1 and sigma (scale or x_min) 1.
        //! Sets fixed seed \a _seed.
        rand_pareto (unsigned int _seed) noexcept : sm::rand_exponential<T, E>(T{1}, _seed) {}
        //! This constructor gives Pareto RN generator with alpha \a alpha and sigma 1
        rand_pareto (T alpha) noexcept : sm::rand_exponential<T, E>(alpha) {}
        //! Construct with given alpha and sigma
        rand_pareto (T alpha, T _sigma) noexcept : sm::rand_exponential<T, E>(alpha) { this->sigma = _sigma; }
        //! This constructor gives RN generator with alpha \a alpha. and a given seed
        rand_pareto (T alpha, unsigned int _seed) noexcept : sm::rand_exponential<T, E>(alpha, _seed) {}
        //! This constructor gives RN generator with alpha \a alpha, sigma \a sigma. and a given seed
        rand_pareto (T alpha, T _sigma, unsigned int _seed) noexcept : sm::rand_exponential<T, E>(alpha, _seed)
        {
            this->sigma = _sigma;
        }
        //! Copy constructor copies the distribution parameters
        rand_pareto (const rand_pareto<T>& rng) noexcept { this->param (rng.param()); }
        //! Copy assignment operator needs to be explicitly defined
        rand_pareto& operator= (const rand_pareto<T>& rng) noexcept
        {
            if (&rng == static_cast<const rand_pareto<T>*>(this)) { return *this; }
            this->param (rng.param());
            return *this;
        }
        //! Get 1 random number from the generator
        T get() noexcept { return this->generate(); }
        //! Get n random numbers from the generator
        std::vector<T> get (std::size_t n) noexcept
        {
            std::vector<T> rtn (n, T{0});
            for (auto& r : rtn) { r = this->generate(); }
            return rtn;
        }
        //! Place n random numbers in the array rtn
        template<std::size_t n>
        void get (std::array<T, n>& rtn) noexcept { for (auto& r : rtn) { r = this->generate(); } }
        //! Return probability density function value, P(x)
        T prob_density (const T x) const noexcept
        {
            if (x < this->sigma) { return T{0}; }
            T alpha = this->dist.lambda(); // 'alpha' is the rate of the underlying exp. distribution
            T f1 = alpha * std::pow (this->sigma, alpha);
            T f2 = std::pow (x, alpha + T{1});
            return f1 / f2;
        }
    private:
        // To generate one sample, obtain a sample from the exponential generator and transform it:
        T generate() { return this->sigma * std::exp (this->dist (this->generator)); }
    };

    //! Generate samples from the von Mises distribution on the circle.
    template <typename T = double, typename E = std::mt19937> requires std::is_floating_point_v<T>
    class rand_vonmises
    {
    public:
        //! Constructors. Note that there's no option to set the seeds of rngn and rngu.
        rand_vonmises() { this->setup_rng(); }
        rand_vonmises (T _mu, T _kappa) : mu(_mu), kappa(_kappa) { this->setup_rng(); }

        //! The mean of the distribution (in radians)
        T mu = T{0};

        /*!
         * The 'concentration'. 1/kappa is equivalent to sigma^2 in the normal
         * distribution If kappa is zero, the distribution is uniform, and for small
         * kappa it is close to uniform.
         */
        T kappa = T{1};

        /*!
         * In the computation (found in get()):
         *   T r = T{1} + std::sqrt (T{1} + T{4} * kappa * kappa);
         *   T rho = (r - std::sqrt (T{2} * r)) / (T{2} * kappa);
         *
         * with T double precision rho is zero until 1.4e-8
         * with T single precision, rho is zero until 0.000325
         */
        static constexpr T get_kappa_for_rho_zero()
        {
            if constexpr (std::is_same_v<T, double>) {
                return T{1e-8};
            } else { // if constexpr (std::is_same_v<T, float>) {
                return T{0.000325};
            }
        }

        static constexpr T kappa_for_rho_zero = get_kappa_for_rho_zero();

        /*!
         * This function samples from the von Mises distribution on the circle. It was
         * adapted from the function random_vonmises() from NumPy's random
         * distributions:
         *
         * https://github.com/numpy/numpy/blob/main/numpy/random/src/distributions/distributions.c#L862
         */
        T get() noexcept // not const, as we may create rngn
        {
            T s = T{0};
            T U = T{0}, V = T{0}, W = T{0}, Y = T{0}, Z = T{0};
            T result = T{0}, mod = T{0};
            int neg = 0;
            if (std::isnan(kappa)) { return std::numeric_limits<T>::quiet_NaN(); }
            if (kappa < kappa_for_rho_zero) {
                // Draw from a uniform distribution for very small values of kappa
                return sm::mathconst<T>::pi * (T{2} * this->rngu->get() - T{1}); // -1 to 1
            } else {
                if (kappa < T{1e-5}) {
                    // second order taylor expansion around kappa = 0. Precise until
                    // relatively large kappas as second order is 0.
                    s = (T{1} / kappa + kappa);
                } else if (kappa <= T{1e6}) {
                        // Path for 1e-5 <= kappa <= 1e6
                        T r = T{1} + std::sqrt (T{1} + T{4} * kappa * kappa);
                        T rho = (r - std::sqrt (T{2} * r)) / (T{2} * kappa);
                        s = (T{1} + rho * rho) / (T{2} * rho);
                } else {
                    // Fallback to wrapped normal distribution for kappa > 1e6
                    // As rngn is only used for kappa > 1e6, we have left setup of rngn to this point
                    if (!this->rngn) { this->rngn = std::make_unique<rand_normal<T, E>>(T{0}, T{1}); }
                    result = mu + std::sqrt(T{1} / kappa) * this->rngn->get();
                    // Ensure result is within bounds
                    if (result < -sm::mathconst<T>::pi) { result += sm::mathconst<T>::two_pi; }
                    if (result > sm::mathconst<T>::pi) { result -= sm::mathconst<T>::two_pi; }
                    return result;
                }

                while (1) {
                    U = this->rngu->get();
                    Z = std::cos (sm::mathconst<T>::pi * U);
                    W = (T{1} + s * Z) / (s + Z);
                    Y = kappa * (s - W);
                    V = this->rngu->get();
                    // V==0.0 is ok here since Y >= 0 always leads to accept, while Y < 0 always rejects
                    if ((Y * (T{2} - Y) - V >= T{0}) || (std::log (Y / V) + T{1} - Y >= T{0})) { break; }
                }

                U = this->rngu->get();

                result = std::acos (W);
                if (U < T{0.5}) { result = -result; }
                result += mu;
                neg = (result < 0);
                mod = std::fabs (result);
                mod = std::fmod (mod + sm::mathconst<T>::pi, sm::mathconst<T>::two_pi) - sm::mathconst<T>::pi;
                if (neg) { mod *= -1; }

                return mod;
            }
        }

#ifndef __APPLE__ // There is no std::cyl_bessel_i on Mac, apparently
        /*!
         * Return probability density function value, P(x)
         */
        T prob_density (const T x) const noexcept
        {
            T bessel = std::cyl_bessel_i (T{0}, this->kappa);
            return std::exp (this->kappa * std::cos (x - this->mu)) / (sm::mathconst<T>::two_pi * bessel);
        }
#endif

    private:
        /*!
         * Set up the uniform random number generator (range [0, 1]) used to sample from the von
         * Mises distribution for most values of kappa.
         */
        void setup_rng() noexcept { this->rngu = std::make_unique<rand_uniform<T, E>>(T{0}, T{1}); }

        //! The uniform number generator
        std::unique_ptr<rand_uniform<T, E>> rngu;
        //! The normal distribution number generator
        std::unique_ptr<rand_normal<T, E>> rngn;
    };

    //! Enumerated class defining groups of characters, such as alphanumericuppercase,
    //! alphanumericlowercase etc.
    enum class chargroup
    {
        alphanumeric,          // 0-9A-Za-z                   62 chars
        alpha,                 // A-Za-z                      52 chars
        alphanumericuppercase, // 0123456789ABCDEF... ...XYZ  36 chars
        alphanumericlowercase, // 0123456789abcdef... ...xyz  36 chars
        alphauppercase,        // A-Z                         26 chars
        alphalowercase,        // a-z                         26 chars
        hexuppercase,          // 0123456789ABCDEF            16 chars
        hexlowercase,          // 0123456789abcdef            16 chars
        decimal,               // 0123456789                  10 chars
        binary_truefalse,              // TF                           2 chars
        binary                 // 01                           2 chars
    };

    //! Generate strings of random characters
    class rand_string
    {
    public:
        //! Default constructor gives a string generator that generates 8 hexlowercase characters
        rand_string() noexcept : length(8) { this->setup_rng(); }
        //! Construct to generate a string of a particular length \a l, in default hexlowercase format
        rand_string (const unsigned int l) noexcept : length(l) { this->setup_rng(); }
        //! Construct with given length \a l and character group \a _cg.
        rand_string (const unsigned int l, const chargroup& _cg) noexcept : length(l), cg(_cg) { this->setup_rng(); }

        //! Get a random string of rand_string::length characters chosen from the given
        //! chargroup rand_string::cg
        std::string get() const noexcept
        {
            // Initialise a string of the correct length
            std::string s(this->length, ' ');

            for (unsigned int i = 0U; i < this->length; ++i) {

                // Get a random number
                unsigned short rn = this->rng->get();

                // Turn the random number into a character, depending on the chargroup
                switch (this->cg) {
                case chargroup::alphanumeric:
                {
                    if (rn < 26) {
                        // lower case
                        s[i] = (char)0x61 + (char)rn;
                    } else if (rn > 51) {
                        // numerals
                        s[i] = (char)0x30 + (char)rn - 52;
                    } else {
                        // upper case
                        s[i] = (char)0x41 + (char)rn - 26;
                    }
                    break;
                }
                case chargroup::alpha:
                {
                    s[i] = (rn < 26 ? (char)0x61 + (char)rn : (char)0x41 + (char)rn - 26);
                    break;
                }
                case chargroup::alphanumericuppercase:
                {
                    s[i] = (rn < 26 ? (char)0x41 + (char)rn : (char)0x30 + (char)rn - 26);
                    break;
                }
                case chargroup::alphanumericlowercase:
                {
                    s[i] = (rn < 26 ? (char)0x61 + (char)rn : (char)0x30 + (char)rn - 26);
                    break;
                }
                case chargroup::alphauppercase:
                {
                    s[i] = (char)0x41 + (char)rn;
                    break;
                }
                case chargroup::alphalowercase:
                {
                    s[i] = (char)0x61 + (char)rn;
                    break;
                }
                case chargroup::hexuppercase:
                {
                    s[i] = (rn < 10 ? (char)rn + 0x30 : (char)rn + 0x41 - 10);
                    break;
                }
                case chargroup::hexlowercase:
                {
                    s[i] = (rn < 10 ? (char)rn + 0x30 : (char)rn + 0x61 - 10);
                    break;
                }
                case chargroup::decimal:
                {
                    s[i] = (char)rn + 0x30;
                    break;
                }
                case chargroup::binary_truefalse:
                {
                    s[i] = rn ? 'T' : 'F';
                    break;
                }
                case chargroup::binary:
                {
                    s[i] = rn ? '1' : '0';
                    break;
                }
                default: { break; }
                }
            }
            return s;
        }

        //! Get a particular length of string - updates rand_string::length first
        std::string get (const unsigned int l) noexcept
        {
            this->length = l;
            return this->get();
        }

        //! Set a new chargroup
        void set_chargroup (const chargroup& _cg) noexcept
        {
            this->cg = _cg;
            this->setup_rng();
        }

    private:

        //! When chargroup changes, the rng has to be re-set up.
        void setup_rng() noexcept
        {
            // Set rng to generate random numbers in correct range
            this->rng = std::make_unique<rand_uniform<unsigned short>>(0, this->numchars()-1);
        }

        //! Return the number of characters total in each chargroup
        unsigned short numchars() const noexcept
        {
            unsigned short n = 0;
            switch (this->cg) {
            case chargroup::alphanumeric: { n = 62; break; }
            case chargroup::alpha: { n = 52; break; }
            case chargroup::alphanumericuppercase:
            case chargroup::alphanumericlowercase: { n = 36; break; }
            case chargroup::alphauppercase:
            case chargroup::alphalowercase: { n = 26; break; }
            case chargroup::hexuppercase:
            case chargroup::hexlowercase: { n = 16; break; }
            case chargroup::decimal: { n = 10; break; }
            case chargroup::binary_truefalse:
            case chargroup::binary: { n = 2; break; }
            default: { n = 0; break; }
            }
            return n;
        }

        //! The number generator
        std::unique_ptr<rand_uniform<unsigned short>> rng;

        //! The number of characters to generate
        unsigned int length;

        //! The group of characters from which to generate a string
        chargroup cg = chargroup::hexlowercase;
    };
}
