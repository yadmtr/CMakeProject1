// -*- C++ -*-
/*!
 * This file is part of sebsjames/maths, a library of maths code for modern C++
 *
 * See https://github.com/sebsjames/maths
 *
 * \file
 *
 * A 4x4 Transformation matrix class
 *
 * \author Seb James
 * \date 2019
 * Initial code author, maintenance
 *
 * \author Alex Blenkinsop
 * \date 2025
 * Improvements to methods that specify rotations and translations
 */
#pragma once

#include <array>
#include <string>
#include <sstream>
#include <iostream>
#include <type_traits>
#include <initializer_list>

#include <sm/mathconst>
#include <sm/quaternion>
#include <sm/vec>
#include <sm/constexpr_math>
#include <sm/mat33>

namespace sm
{
    // Forward declare class and stream operator
    template <typename F> requires std::is_floating_point_v<F> struct mat44;
    template <typename F> std::ostream& operator<< (std::ostream&, const mat44<F>&);

    /*!
     * This implements a 4x4 transformation matrix, for use in computer graphics applications in
     * which 3D coordinates are often given as 4D homogeneous coordinates (with the fourth element
     * chosen to be equal to 1). It's used a lot in sm::Visual. The matrix data is stored in
     * mat44::mat, an array of 16 floating point numbers. The numbers must be floating point,
     * because there is a method that returns a quaternion<F>, where F is required to be floating
     * point.
     *
     * \templateparam F The floating point type in which to store the mat44's data.
     */
    template <typename F> requires std::is_floating_point_v<F>
    struct mat44
    {
        //! Default constructor
        constexpr mat44() noexcept { this->setToIdentity(); }
        //! Construct from a mat33 rotation matrix
        constexpr mat44 (const sm::mat33<F>& other) noexcept
        {
            this->mat[0] = other[0];
            this->mat[1] = other[1];
            this->mat[2] = other[2];
            this->mat[3] = F{0};

            this->mat[4] = other[3];
            this->mat[5] = other[4];
            this->mat[6] = other[5];
            this->mat[7] = F{0};

            this->mat[8] = other[6];
            this->mat[9] = other[7];
            this->mat[10] = other[8];
            this->mat[11] = F{0};

            this->mat[12] = F{0};
            this->mat[13] = F{0};
            this->mat[14] = F{0};
            this->mat[15] = F{1};
        }
        //! Initializer list construction
        constexpr mat44 (std::initializer_list<F> other) noexcept
        {
            unsigned int i = 0u;
            for (i = 0u; i < 16u; ++i) { this->mat[i] = F{0}; }
            i = 0u;
            for (F elem : other) {
                this->mat[i++] = elem;
                if (i == 16u) { break; } // only first 16 elements can be copied
            }
        }
        //! Construct with an array
        constexpr mat44 (const std::array<F, 16>& other) noexcept { this->mat = other; }
        //! User-declared copy constructor
        constexpr mat44 (const mat44<F>& other) noexcept : mat(other.mat) {}
        //! User-declared copy assignment constructor
        constexpr mat44<F>& operator= (const mat44<F>& other) noexcept
        {
            std::copy (other.mat.begin(), other.mat.end(), mat.begin());
            return *this;
        }
        //! Explicitly defaulted  move constructor
        mat44 (mat44<F>&& other) noexcept = default;
        //! Explicitly defaulted move assignment constructor
        mat44<F>& operator= (mat44<F>&& other) noexcept = default;

        /*!
         * The transformation matrix data, arranged in column major format to be OpenGL
         * friendly.
         */
        alignas(std::array<F, 16>) std::array<F, 16> mat;

        //! Return a string representation of the matrix
        std::string str() const noexcept
        {
            std::stringstream ss;
            ss <<"[ "<< mat[0]<<" , "<<mat[4]<<" , "<<mat[8]<<" , "<<mat[12]<<" ;\n";
            ss <<"  "<< mat[1]<<" , "<<mat[5]<<" , "<<mat[9]<<" , "<<mat[13]<<" ;\n";
            ss <<"  "<< mat[2]<<" , "<<mat[6]<<" , "<<mat[10]<<" , "<<mat[14]<<" ;\n";
            ss <<"  "<< mat[3]<<" , "<<mat[7]<<" , "<<mat[11]<<" , "<<mat[15]<<" ]";
            return ss.str();
        }

        //! Return a string representation of the passed-in column-major array
        static std::string str (const std::array<F, 16>& arr) noexcept
        {
            std::stringstream ss;
            ss <<"[ "<< arr[0]<<" , "<<arr[4]<<" , "<<arr[8]<<" , "<<arr[12]<<" ;\n";
            ss <<"  "<< arr[1]<<" , "<<arr[5]<<" , "<<arr[9]<<" , "<<arr[13]<<" ;\n";
            ss <<"  "<< arr[2]<<" , "<<arr[6]<<" , "<<arr[10]<<" , "<<arr[14]<<" ;\n";
            ss <<"  "<< arr[3]<<" , "<<arr[7]<<" , "<<arr[11]<<" , "<<arr[15]<<" ]";
            return ss.str();
        }

        //! Self-explanatory
        constexpr void setToIdentity() noexcept
        {
            this->mat.fill (F{0});
            this->mat[0] = F{1};
            this->mat[5] = F{1};
            this->mat[10] = F{1};
            this->mat[15] = F{1};
        }

        //! Set *this from a transform matrix to transform a coordinate into the given coordinate basis set
        constexpr void frombasis_inplace (const sm::vec<F> bx, const sm::vec<F> by, const sm::vec<F> bz)
        {
            (*this) = sm::mat44<F>::frombasis (bx, by, bz);
        }

        //! Create a transform matrix to transform a coordinate into the given coordinate basis set
        static constexpr mat44<F> frombasis (const sm::vec<F> bx, const sm::vec<F> by, const sm::vec<F> bz)
        {
            sm::mat44<F> m;

            m[0] = bx.x();
            m[1] = bx.y();
            m[2] = bx.z();
            m[3] = 0.0f;

            m[4] = by.x();
            m[5] = by.y();
            m[6] = by.z();
            m[7] = 0.0f;

            m[8] = bz.x();
            m[9] = bz.y();
            m[10] = bz.z();
            m[11] = 0.0f;

            m[12] = 0.0f;
            m[13] = 0.0f;
            m[14] = 0.0f;
            m[15] = 1.0f;

            return m;
        }

        //! Access elements of the matrix (returns ref, so not const)
        constexpr F& operator[] (const unsigned int idx) noexcept { return this->mat[idx]; }

        //! Access elements of the matrix with const promise
        constexpr F operator[] (const unsigned int idx) const noexcept { return this->mat[idx]; }

        //! Access a given row of the matrix
        constexpr sm::vec<F, 4> row (unsigned int idx) const noexcept
        {
            sm::vec<F, 4> r = {F{0}, F{0}, F{0}, F{0}};
            if (idx > 3U) { return r; }
            r[0] = this->mat[idx];
            r[1] = this->mat[idx+4];
            r[2] = this->mat[idx+8];
            r[3] = this->mat[idx+12];
            return r;
        }

        //! Access a given column of the matrix
        constexpr sm::vec<F, 4> col (unsigned int idx) const noexcept
        {
            sm::vec<F, 4> c = {F{0}, F{0}, F{0}, F{0}};
            if (idx > 3U) { return c; }
            idx *= 4U;
            c[0] = this->mat[idx];
            c[1] = this->mat[++idx];
            c[2] = this->mat[++idx];
            c[3] = this->mat[++idx];
            return c;
        }

        //! Apply pre-translation specified by vector @dv as this = m * this (pre-multiply)
        template<typename T, std::size_t N = 3> requires std::is_arithmetic_v<T> && (N == 3 || N == 4)
        constexpr void pretranslate (const sm::vec<T, N>& dv) noexcept
        {
            this->mat[12] += dv[0];
            this->mat[13] += dv[1];
            this->mat[14] += dv[2];
        }

        //! Apply pre-translation specified by vector @dv provided as array of three coordinates as
        //! this = m * this (pre-multiply)
        template<typename T, std::size_t N = 3> requires std::is_arithmetic_v<T> && (N == 3 || N == 4)
        constexpr void pretranslate (const std::array<T, N>& dv) noexcept
        {
            this->mat[12] += dv[0];
            this->mat[13] += dv[1];
            this->mat[14] += dv[2];
        }

        //! Apply pre-translation specified by coordinates @dx, @dy and @dz as this = m * this
        //! (pre-multiply)
        template<typename T> requires std::is_arithmetic_v<T>
        constexpr void pretranslate (const T& dx, const T& dy, const T& dz) noexcept
        {
            this->mat[12] += dx;
            this->mat[13] += dy;
            this->mat[14] += dz;
        }

        //! Apply translation specified by vector @dv as this = this * m (post-multiply)
        template<typename T, std::size_t N = 3> requires std::is_arithmetic_v<T> && (N == 3 || N == 4)
        constexpr void translate (const sm::vec<T, N>& dv) noexcept
        {
            mat44<T> trans_mat;
            trans_mat[12] = dv[0];
            trans_mat[13] = dv[1];
            trans_mat[14] = dv[2];

            *this *= trans_mat;
        }

        //! Apply translation specified by vector @dv provided as array of three coordinates as this
        //! = this * m (post-multiply)
        template<typename T, std::size_t N = 3> requires std::is_arithmetic_v<T> && (N == 3 || N == 4)
        constexpr void translate (const std::array<T, N>& dv) noexcept
        {
            mat44<T> trans_mat;
            trans_mat[12] = dv[0];
            trans_mat[13] = dv[1];
            trans_mat[14] = dv[2];

            *this *= trans_mat;
        }

        //! Apply translation specified by coordinates @dx, @dy and @dz. as this = this * m
        //! (post-multiply)
        template<typename T> requires std::is_arithmetic_v<T>
        constexpr void translate (const T& dx, const T& dy, const T& dz) noexcept
        {
            mat44<T> trans_mat;
            trans_mat[12] = dx;
            trans_mat[13] = dy;
            trans_mat[14] = dz;

            *this *= trans_mat;
        }

        //! Scaling transformation by individual dims
        template<typename T> requires std::is_arithmetic_v<T>
        constexpr void scale (const T& scl_x, const T& scl_y, const T& scl_z) noexcept
        {
            // This is the rotation matrix multiplied by a diagonalized matrix made from scl_x/y/z
            this->mat[0] *= scl_x;
            this->mat[1] *= scl_x;
            this->mat[2] *= scl_x;

            this->mat[4] *= scl_y;
            this->mat[5] *= scl_y;
            this->mat[6] *= scl_y;

            this->mat[8] *= scl_z;
            this->mat[9] *= scl_z;
            this->mat[10] *= scl_z;
        }

        //! Scaling transformation by vector. this = this * m (post-multiplication)
        template<typename T, std::size_t N = 3> requires std::is_arithmetic_v<T> && (N == 3 || N == 4)
        constexpr void scale (const sm::vec<T, N>& scl) noexcept
        {
            this->mat[0] *= scl[0];
            this->mat[1] *= scl[0];
            this->mat[2] *= scl[0];

            this->mat[4] *= scl[1];
            this->mat[5] *= scl[1];
            this->mat[6] *= scl[1];

            this->mat[8] *= scl[2];
            this->mat[9] *= scl[2];
            this->mat[10] *= scl[2];
        }

        //! Scaling transformation by array. this = this * m (post-multiplication)
        template<typename T, std::size_t N = 3> requires std::is_arithmetic_v<T> && (N == 3 || N == 4)
        constexpr void scale (const std::array<T, N>& scl) noexcept
        {
            this->mat[0] *= scl[0];
            this->mat[1] *= scl[0];
            this->mat[2] *= scl[0];

            this->mat[4] *= scl[1];
            this->mat[5] *= scl[1];
            this->mat[6] *= scl[1];

            this->mat[8] *= scl[2];
            this->mat[9] *= scl[2];
            this->mat[10] *= scl[2];
        }

        //! Scaling transformation by scalar. this = this * m (post-multiplication)
        template<typename T> requires std::is_arithmetic_v<T>
        constexpr void scale (const T& scl) noexcept
        {
            this->mat[0] *= scl;
            this->mat[1] *= scl;
            this->mat[2] *= scl;

            this->mat[4] *= scl;
            this->mat[5] *= scl;
            this->mat[6] *= scl;

            this->mat[8] *= scl;
            this->mat[9] *= scl;
            this->mat[10] *= scl;
        }

        //! Compute determinant for 4x4 matrix @cm
        static constexpr F determinant (const std::array<F, 16>& cm) noexcept
        {
            // Configure the 3x3 matrices that have to be evaluated to get the 4x4 det.
            std::array<F, 9> cm33;

            // First 3x3 matrix
            cm33[0] = cm[5];
            cm33[1] = cm[6];
            cm33[2] = cm[7];
            cm33[3] = cm[9];
            cm33[4] = cm[10];
            cm33[5] = cm[11];
            cm33[6] = cm[13];
            cm33[7] = cm[14];
            cm33[8] = cm[15];

            F det = cm[0] * mat33<F>::determinant (cm33);

            // Second 3x3
            cm33[0] = cm[1];
            cm33[1] = cm[2];
            cm33[2] = cm[3];
            cm33[3] = cm[9];
            cm33[4] = cm[10];
            cm33[5] = cm[11];
            cm33[6] = cm[13];
            cm33[7] = cm[14];
            cm33[8] = cm[15];

            det -= cm[4] * mat33<F>::determinant (cm33);

            // Third 3x3
            cm33[0] = cm[1];
            cm33[1] = cm[2];
            cm33[2] = cm[3];
            cm33[3] = cm[5];
            cm33[4] = cm[6];
            cm33[5] = cm[7];
            cm33[6] = cm[13];
            cm33[7] = cm[14];
            cm33[8] = cm[15];

            det += cm[8] * mat33<F>::determinant (cm33);

            // Final 3x3
            cm33[0] = cm[1];
            cm33[1] = cm[2];
            cm33[2] = cm[3];
            cm33[3] = cm[5];
            cm33[4] = cm[6];
            cm33[5] = cm[7];
            cm33[6] = cm[9];
            cm33[7] = cm[10];
            cm33[8] = cm[11];

            det -= cm[12] * mat33<F>::determinant (cm33);

            return det;
        }

        //! Compute determinant for this->mat
        constexpr F determinant() const noexcept { return mat44<F>::determinant (this->mat); }

        /*!
         * The adjugate is the transpose of the cofactor matrix. Recipe:
         * 1. Get the cofactor matrix (with this->cofactor())
         * 2. Obtain the adjugate matrix by transposing the cofactor matrix
         */
        constexpr std::array<F, 16> adjugate() const noexcept { return mat44<F>::transpose (this->cofactor()); }

        /*!
         * Compute the cofactor matrix of this->mat. Recipe:
         * 1. Create matrix of minors
         * 2. Multiply matrix of minors by a checkerboard pattern to give the cofactor matrix
         */
        constexpr std::array<F, 16> cofactor() const noexcept
        {
            std::array<F, 16> cofac;

            // Keep to column-major format for all matrices. The elements of the matrix
            // of minors is found, but the cofactor matrix is populated, applying the
            // alternating pattern of +/- as we go.

            // 0.
            std::array<F, 9> minorElem;
            minorElem[0] = this->mat[5];
            minorElem[3] = this->mat[9];
            minorElem[6] = this->mat[13];

            minorElem[1] = this->mat[6];
            minorElem[4] = this->mat[10];
            minorElem[7] = this->mat[14];

            minorElem[2] = this->mat[7];
            minorElem[5] = this->mat[11];
            minorElem[8] = this->mat[15];

            cofac[0] = mat33<F>::determinant (minorElem);

            // 1. Next minor elem matrix has only 3 elements changed
            minorElem[0] = this->mat[4];
            minorElem[3] = this->mat[8];
            minorElem[6] = this->mat[12];
            cofac[1] = -mat33<F>::determinant (minorElem);

            // 2
            minorElem[1] = this->mat[5];
            minorElem[4] = this->mat[9];
            minorElem[7] = this->mat[13];
            cofac[2] = mat33<F>::determinant (minorElem);

            // 3
            minorElem[2] = this->mat[6];
            minorElem[5] = this->mat[10];
            minorElem[8] = this->mat[14];
            cofac[3] = -mat33<F>::determinant (minorElem);

            // 4.
            minorElem[0] = this->mat[1];
            minorElem[3] = this->mat[9];
            minorElem[6] = this->mat[13];

            minorElem[1] = this->mat[2];
            minorElem[4] = this->mat[10];
            minorElem[7] = this->mat[14];

            minorElem[2] = this->mat[3];
            minorElem[5] = this->mat[11];
            minorElem[8] = this->mat[15];

            cofac[4] = -mat33<F>::determinant (minorElem);

            // 5.
            minorElem[0] = this->mat[0];
            minorElem[3] = this->mat[8];
            minorElem[6] = this->mat[12];
            cofac[5] = mat33<F>::determinant (minorElem);

            // 6.
            minorElem[1] = this->mat[1];
            minorElem[4] = this->mat[9];
            minorElem[7] = this->mat[13];
            cofac[6] = -mat33<F>::determinant (minorElem);

            // 7.
            minorElem[2] = this->mat[2];
            minorElem[5] = this->mat[10];
            minorElem[8] = this->mat[14];
            cofac[7] = mat33<F>::determinant (minorElem);

            // 8.
            minorElem[0] = this->mat[1];
            minorElem[3] = this->mat[5];
            minorElem[6] = this->mat[13];

            minorElem[1] = this->mat[2];
            minorElem[4] = this->mat[6];
            minorElem[7] = this->mat[14];

            minorElem[2] = this->mat[3];
            minorElem[5] = this->mat[7];
            minorElem[8] = this->mat[15];

            cofac[8] = mat33<F>::determinant (minorElem);

            // 9.
            minorElem[0] = this->mat[0];
            minorElem[3] = this->mat[4];
            minorElem[6] = this->mat[12];
            cofac[9] = -mat33<F>::determinant (minorElem);

            // 10.
            minorElem[1] = this->mat[1];
            minorElem[4] = this->mat[5];
            minorElem[7] = this->mat[13];
            cofac[10] = mat33<F>::determinant (minorElem);

            // 11.
            minorElem[2] = this->mat[2];
            minorElem[5] = this->mat[6];
            minorElem[8] = this->mat[14];
            cofac[11] = -mat33<F>::determinant (minorElem);

            // 12.
            minorElem[0] = this->mat[1];
            minorElem[3] = this->mat[5];
            minorElem[6] = this->mat[9];

            minorElem[1] = this->mat[2];
            minorElem[4] = this->mat[6];
            minorElem[7] = this->mat[10];

            minorElem[2] = this->mat[3];
            minorElem[5] = this->mat[7];
            minorElem[8] = this->mat[11];

            cofac[12] = -mat33<F>::determinant (minorElem);

            // 13.
            minorElem[0] = this->mat[0];
            minorElem[3] = this->mat[4];
            minorElem[6] = this->mat[8];
            cofac[13] = mat33<F>::determinant (minorElem);

            // 14.
            minorElem[1] = this->mat[1];
            minorElem[4] = this->mat[5];
            minorElem[7] = this->mat[9];
            cofac[14] = -mat33<F>::determinant (minorElem);

            // 15.
            minorElem[2] = this->mat[2];
            minorElem[5] = this->mat[6];
            minorElem[8] = this->mat[10];
            cofac[15] = mat33<F>::determinant (minorElem);

            return cofac;
        }

        //! Compute the trace of the matrix (the sum of the diagonal elements)
        constexpr F trace() const noexcept { return this->mat[0] + this->mat[5] + this->mat[10] + this->mat[15]; }

        /*!
         * Return the inverse matrix.
         *
         * Implement inversion using determinant method. inverse is (1/det) x adjugate
         * matrix.
         *
         * 1. Compute determinant of this->mat (if 0, then there's no inverse)
         * 2. Obtain the adjugate matrix
         * 3. Get the inverse by multiplying 1/determinant by the adjugate
         */
        constexpr mat44<F> inverse() noexcept
        {
            F det = this->determinant();
            mat44<F> m;
            if (det == F{0}) {
                // The transform matrix has no inverse (determinant is 0)
                m.mat.fill (F{0});
            } else {
                m.mat = this->adjugate();
                m *= (F{1} / det);
            }
            return m;
        }

        /*!
         * Turn the matrix into its inverse.
         *
         * Implement inversion using determinant method. inverse is (1/det) x adjugate
         * matrix.
         *
         * 1. Compute determinant of this->mat (if 0, then there's no inverse)
         * 2. Obtain the adjugate matrix
         * 3. Get the inverse by multiplying 1/determinant by the adjugate
         */
        constexpr void inverse_inplace() noexcept
        {
            F det = this->determinant();
            if (det == F{0}) {
                // The transform matrix has no inverse (determinant is 0)
                this->mat.fill (F{0});
            } else {
                this->mat = this->adjugate();
                *this *= (F{1} / det);
            }
        }

        /*!
         * Place a pure rotation q (with no translation) into a mat44<F> and return it.
         *
         * This algorithm was obtained from:
         * http://www.j3d.org/matrix_faq/matrfaq_latest.html#Q54 (but was it transposed?
         * seems so. See also https://www.songho.ca/opengl/gl_quaternion.html#overview
         * and https://danceswithcode.net/engineeringnotes/quaternions/quaternions.html)
         */
        template <typename T> requires std::is_arithmetic_v<T>
        static constexpr mat44<F> pure_rotation (const sm::quaternion<T>& q) noexcept
        {
            const F qx = static_cast<F>(q.x);
            const F qy = static_cast<F>(q.y);
            const F qz = static_cast<F>(q.z);
            const F qw = static_cast<F>(q.w);
            const F f2x = qx * F{2};
            const F f2y = qy * F{2};
            const F f2z = qz * F{2};
            const F f2xw = f2x * qw;
            const F f2yw = f2y * qw;
            const F f2zw = f2z * qw;
            const F f2xx = f2x * qx;
            const F f2xy = f2x * qy;
            const F f2xz = f2x * qz;
            const F f2yy = f2y * qy;
            const F f2yz = f2y * qz;
            const F f2zz = f2z * qz;

            mat44<F> m;
            m[0]  = F{1} - (f2yy + f2zz);
            m[1]  =         f2xy + f2zw;
            m[2]  =         f2xz - f2yw;
            m[3]  = F{0};
            m[4]  =         f2xy - f2zw;
            m[5]  = F{1} - (f2xx + f2zz);
            m[6]  =         f2yz + f2xw;
            m[7]  = F{0};
            m[8]  =         f2xz + f2yw;
            m[9]  =         f2yz - f2xw;
            m[10] = F{1} - (f2xx + f2yy);
            m[11] = F{0};
            m[12] = F{0};
            m[13] = F{0};
            m[14] = F{0};
            m[15] = F{1};

            return m;
        }

        //! Apply the rotation q to this as a pre-multiplication: this = R * this
        template <typename T> requires std::is_arithmetic_v<T>
        constexpr void prerotate (const sm::quaternion<T>& q) noexcept { *this = this->pure_rotation (q) * *this; }

        /*!
         * Pre-rotate an angle theta radians about axis (specified as std::array). By default, axis
         * is not required to be normalized because quaternion::rotate will do this.
         *
         * Result is this = R * this  (rotation pre-multiplies)
         *
         * \tparam renorm If true, renormalize axis to length 1, if false, assume axis has already
         * been renormalized
         *
         * \tparam T type for operations, usually compiler-detected from axis and theta
         *
         * \tparam N Number of elements in the axis vector, compiler-detected from axis. Allows
         * passing of 3D and (3+1)D vectors
         */
        template <bool renorm = true, typename T = F, std::size_t N = 3> requires std::is_arithmetic_v<T> && (N == 3 || N == 4)
        constexpr void prerotate (const std::array<T, N>& axis, const T& theta) noexcept
        {
            sm::quaternion<T> q;
            q.template rotate<std::array<T, N>, renorm> (axis, theta);
            this->prerotate<T> (q);
        }

        /*!
         * Pre-rotate an angle theta radians about axis (specified as sm::vec). By default, axis is
         * not required to be normalized because quaternion::rotate will do this.
         *
         * Result is this = R * this  (rotation pre-multiplies)
         *
         * \tparam renorm If true, renormalize axis to length 1, if false, assume axis has already
         * been renormalized
         *
         * \tparam T type for operations, usually compiler-detected from axis and theta
         *
         * \tparam N Number of elements in the axis vector, compiler-detected from axis. Allows
         * passing of 3D and (3+1)D vectors
         */
        template <bool renorm = true, typename T = F, std::size_t N = 3> requires std::is_arithmetic_v<T> && (N == 3 || N == 4)
        constexpr void prerotate (const sm::vec<T, N>& axis, const T& theta) noexcept
        {
            sm::quaternion<T> q;
            q.template rotate<sm::vec<T, N>, renorm> (axis, theta);
            this->prerotate<T> (q);
        }

        //! Rotation by post-multiplication of a pure rotation matrix: this = this * R
        template <typename T> requires std::is_arithmetic_v<T>
        constexpr void rotate (const sm::quaternion<T>& q) noexcept { *this *= this->pure_rotation (q); }

        /*!
         * Rotate an angle theta radians about axis (specified as std::array). By default, the axis
         * is not required to be normalized because quaternion::rotate will do this.
         *
         * Result: this = this * R (post-multiplication)
         *
         * \tparam renorm If true, renormalize axis to length 1, if false, assume axis has already
         * been renormalized
         *
         * \tparam T type for operations, usually compiler-detected from axis and theta
         *
         * \tparam N Number of elements in the axis vector, compiler-detected from axis. Allows
         * passing of 3D and (3+1)D vectors
         */
        template <bool renorm = true, typename T = F, std::size_t N = 3> requires std::is_arithmetic_v<T> && (N == 3 || N == 4)
        constexpr void rotate (const std::array<T, N>& axis, const T& theta) noexcept
        {
            sm::quaternion<T> q;
            q.template rotate<std::array<T, N>, renorm> (axis, theta);
            this->rotate<T> (q);
        }

        /*!
         * Rotate an angle theta radians about axis (specified as sm::vec). By default, the axis is
         * not required to be normalized because quaternion::rotate will do this.
         *
         * Result: this = this * R (post-multiplication)
         *
         * \tparam renorm If true, renormalize axis to length 1, if false, assume axis has already
         * been renormalized
         *
         * \tparam T type for operations, usually compiler-detected from axis and theta
         *
         * \tparam N Number of elements in the axis vector, compiler-detected from axis. Allows
         * passing of 3D and (3+1)D vectors
         */
        template <bool renorm = true, typename T = F, std::size_t N = 3> requires std::is_arithmetic_v<T> && (N == 3 || N == 4)
        constexpr void rotate (const sm::vec<T, N>& axis, const T& theta) noexcept
        {
            sm::quaternion<T> q;
            q.template rotate<sm::vec<T, N>, renorm> (axis, theta);
            this->rotate<T> (q);
        }

        //! Returns the linear part of the 4x4 matrix (the top left 3x3 matrix)
        constexpr sm::mat33<F> linear() const noexcept
        {
            sm::mat33<F> m;

            m[0] = this->mat[0];
            m[1] = this->mat[1];
            m[2] = this->mat[2];
            m[3] = this->mat[4];
            m[4] = this->mat[5];
            m[5] = this->mat[6];
            m[6] = this->mat[8];
            m[7] = this->mat[9];
            m[8] = this->mat[10];

            return m;
        }

        //! Returns the translation part of the 4x4 matrix (top three rows of last column)
        constexpr sm::vec<F, 3> translation() const noexcept
        {
            return { this->mat[12], this->mat[13], this->mat[14] };
        }

        /*!
         * Returns the rotation part of the 4x4 matrix (the top left 3x3 matrix, as returned by
         * mat44::linear) as a quaternion.
         *
         * This does the equivalent of this->linear().rotation() (that is, you can find
         * mat33::rotation which is the same as this function).
         *
         * It assumes that your 4x4 matrix encodes rotations without scaling. You could use
         * rotation_mat44().rotation() to first exclude a uniform or pre-applied scaling.
         *
         * It does *not* check that the matrix determinant is 1 (you could do that first if you need
         * to).
         *
         * It does *not* normalize the generated quaternion before returning it (you could do that
         * afterwards if you need to).
         *
         * Hat tip for the algorithm:
         * https://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/
         */
        constexpr sm::quaternion<F> rotation() const noexcept
        {
            sm::quaternion<F> q;

            F tr = mat[0] + mat[5] + mat[10];

            if (tr > F{0}) {
                F S = sm::cem::sqrt (tr + F{1}) * F{2}; // S=4*qw
                q.w = F{0.25} * S;
                q.x = (mat[6] - mat[9]) / S;
                q.y = (mat[8] - mat[2]) / S;
                q.z = (mat[1] - mat[4]) / S;
            } else if ((mat[0] > mat[5]) && (mat[0] > mat[10])) {
                F S = sm::cem::sqrt (F{1} + mat[0] - mat[5] - mat[10]) * F{2}; // S=4*qx
                q.w = (mat[6] - mat[9]) / S;
                q.x = F{0.25} * S;
                q.y = (mat[4] + mat[1]) / S;
                q.z = (mat[8] + mat[2]) / S;
            } else if (mat[5] > mat[10]) {
                F S = sm::cem::sqrt (F{1} + mat[5] - mat[0] - mat[10]) * F{2}; // S=4*qy
                q.w = (mat[8] - mat[2]) / S;
                q.x = (mat[4] + mat[1]) / S;
                q.y = F{0.25} * S;
                q.z = (mat[9] + mat[6]) / S;
            } else {
                F S = sm::cem::sqrt (F{1} + mat[10] - mat[0] - mat[6]) * F{2}; // S=4*qz
                q.w = (mat[1] - mat[4]) / S;
                q.x = (mat[8] + mat[2]) / S;
                q.y = (mat[9] + mat[6]) / S;
                q.z = F{0.25} * S;
            }

            return q;
        }

        //! Obtain the rotation, excluding any uniform, or non-uniform-but-applied-before-rotations scaling.
        constexpr sm::mat33<F> rotation_mat33() const noexcept
        {
            sm::vec<F, 3> c0 = { mat[0], mat[1], mat[2] };
            sm::vec<F, 3> c1 = { mat[4], mat[5], mat[6] };
            sm::vec<F, 3> c2 = { mat[8], mat[9], mat[10] };
            c0 /= c0.length();
            c1 /= c1.length();
            c2 /= c2.length();
            sm::mat33<F> m = { c0[0], c0[1], c0[2], c1[0], c1[1], c1[2], c2[0], c2[1], c2[2] };
            return m;
        }

        //! Obtain the rotation, excluding any uniform, or non-uniform-but-applied-before-rotations scaling.
        constexpr sm::mat44<F> rotation_mat44() const noexcept
        {
            sm::vec<F, 3> c0 = { mat[0], mat[1], mat[2] };
            sm::vec<F, 3> c1 = { mat[4], mat[5], mat[6] };
            sm::vec<F, 3> c2 = { mat[8], mat[9], mat[10] };
            c0 /= c0.length();
            c1 /= c1.length();
            c2 /= c2.length();
            sm::mat44<F> m = {
                c0[0], c0[1], c0[2], F{0},
                c1[0], c1[1], c1[2], F{0},
                c2[0], c2[1], c2[2], F{0},
                F{0},  F{0},  F{0},  F{1}
            };
            return m;
        }

        //! Obtain scaling from this matrix, returning as a vector of scale factors
        constexpr sm::vec<F, 3> scaling_vec() const noexcept
        {
            return sm::vec<F, 3>{
                sm::cem::sqrt (mat[0] * mat[0] + mat[1] * mat[1] + mat[2] * mat[2]), // length of 1st col
                sm::cem::sqrt (mat[4] * mat[4] + mat[5] * mat[5] + mat[6] * mat[6]),
                sm::cem::sqrt (mat[8] * mat[8] + mat[9] * mat[9] + mat[10] * mat[10])
            };
        }

        //! Obtain scaling from this matrix, returning as a 3x3 mat33
        constexpr sm::mat33<F> scaling_mat33() const noexcept
        {
            sm::mat33<F> m = {
                sm::cem::sqrt (mat[0] * mat[0] + mat[1] * mat[1] + mat[2] * mat[2]),   F{0}, F{0},
                F{0}, sm::cem::sqrt (mat[4] * mat[4] + mat[5] * mat[5] + mat[6] * mat[6]),   F{0},
                F{0}, F{0}, sm::cem::sqrt (mat[8] * mat[8] + mat[9] * mat[9] + mat[10] * mat[10])
            };
            return m;
        }

        //! Obtain scaling from this matrix, returning as a 4x4 mat44
        constexpr sm::mat44<F> scaling_mat44() const noexcept
        {
            sm::mat44<F> m = {
                sm::cem::sqrt (mat[0] * mat[0] + mat[1] * mat[1] + mat[2] * mat[2]),   F{0}, F{0}, F{0},
                F{0}, sm::cem::sqrt (mat[4] * mat[4] + mat[5] * mat[5] + mat[6] * mat[6]),   F{0}, F{0},
                F{0}, F{0}, sm::cem::sqrt (mat[8] * mat[8] + mat[9] * mat[9] + mat[10] * mat[10]), F{0},
                F{0}, F{0}, F{0},                                                                  F{1}
            };
            return m;
        }

        //! Add m2 to this matrix
        constexpr void operator+= (const mat44<F>& m2) noexcept
        {
            for (unsigned int i = 0; i < 16; ++i) { this->mat[i] += m2.mat[i]; }
        }

        //! Return this + m2
        constexpr mat44<F> operator+ (const mat44<F>& m2) const noexcept
        {
            mat44<F> m = { F{0} };
            for (unsigned int i = 0; i < 16; ++i) { m[i] = this->mat[i] + m2.mat[i]; }
            return m;
        }

        //! Add scalar to this matrix
        constexpr void operator+= (const F& f) noexcept
        {
            for (unsigned int i = 0; i < 16; ++i) { this->mat[i] += f; }
        }

        //! Return this + scalar
        constexpr mat44<F> operator+ (const F& f) const noexcept
        {
            mat44<F> m = { F{0} };
            for (unsigned int i = 0; i < 16; ++i) { m[i] = this->mat[i] + f; }
            return m;
        }

        //! Subtract m2 from this matrix
        constexpr void operator-= (const mat44<F>& m2) noexcept
        {
            for (unsigned int i = 0; i < 16; ++i) { this->mat[i] -= m2.mat[i]; }
        }

        //! Return this - m2
        constexpr mat44<F> operator- (const mat44<F>& m2) const noexcept
        {
            mat44<F> m = { F{0} };
            for (unsigned int i = 0; i < 16; ++i) { m[i] = this->mat[i] - m2.mat[i]; }
            return m;
        }

        //! Subtract scalar from this matrix
        constexpr void operator-= (const F& f) noexcept
        {
            for (unsigned int i = 0; i < 16; ++i) { this->mat[i] -= f; }
        }

        //! Return this - scalar
        constexpr mat44<F> operator- (const F& f) const noexcept
        {
            mat44<F> m = { F{0} };
            for (unsigned int i = 0; i < 16; ++i) { m[i] = this->mat[i] - f; }
            return m;
        }

        //! Right-multiply this->mat with m2
        constexpr void operator*= (const mat44<F>& m2) noexcept
        {
            std::array<F, 16> m;
            // Top row
            m[0] = this->mat[0] * m2.mat[0] + this->mat[4] * m2.mat[1] + this->mat[8] * m2.mat[2] + this->mat[12] * m2.mat[3];
            m[4] = this->mat[0] * m2.mat[4] + this->mat[4] * m2.mat[5] + this->mat[8] * m2.mat[6] + this->mat[12] * m2.mat[7];
            m[8] = this->mat[0] * m2.mat[8] + this->mat[4] * m2.mat[9] + this->mat[8] * m2.mat[10] + this->mat[12] * m2.mat[11];
            m[12] = this->mat[0] * m2.mat[12] + this->mat[4] * m2.mat[13] + this->mat[8] * m2.mat[14] + this->mat[12] * m2.mat[15];
            // Second row
            m[1] = this->mat[1] * m2.mat[0] + this->mat[5] * m2.mat[1] + this->mat[9] * m2.mat[2] + this->mat[13] * m2.mat[3];
            m[5] = this->mat[1] * m2.mat[4] + this->mat[5] * m2.mat[5] + this->mat[9] * m2.mat[6] + this->mat[13] * m2.mat[7];
            m[9] = this->mat[1] * m2.mat[8] + this->mat[5] * m2.mat[9] + this->mat[9] * m2.mat[10] + this->mat[13] * m2.mat[11];
            m[13] = this->mat[1] * m2.mat[12] + this->mat[5] * m2.mat[13] + this->mat[9] * m2.mat[14] + this->mat[13] * m2.mat[15];
            // Third row
            m[2] = this->mat[2] * m2.mat[0] + this->mat[6] * m2.mat[1] + this->mat[10] * m2.mat[2] + this->mat[14] * m2.mat[3];
            m[6] = this->mat[2] * m2.mat[4] + this->mat[6] * m2.mat[5] + this->mat[10] * m2.mat[6] + this->mat[14] * m2.mat[7];
            m[10] = this->mat[2] * m2.mat[8] + this->mat[6] * m2.mat[9] + this->mat[10] * m2.mat[10] + this->mat[14] * m2.mat[11];
            m[14] = this->mat[2] * m2.mat[12] + this->mat[6] * m2.mat[13] + this->mat[10] * m2.mat[14] + this->mat[14] * m2.mat[15];
            // Bottom row
            m[3] = this->mat[3] * m2.mat[0] + this->mat[7] * m2.mat[1] + this->mat[11] * m2.mat[2] + this->mat[15] * m2.mat[3];
            m[7] = this->mat[3] * m2.mat[4] + this->mat[7] * m2.mat[5] + this->mat[11] * m2.mat[6] + this->mat[15] * m2.mat[7];
            m[11] = this->mat[3] * m2.mat[8] + this->mat[7] * m2.mat[9] + this->mat[11] * m2.mat[10] + this->mat[15] * m2.mat[11];
            m[15] = this->mat[3] * m2.mat[12] + this->mat[7] * m2.mat[13] + this->mat[11] * m2.mat[14] + this->mat[15] * m2.mat[15];

            this->mat.swap (m);
        }

        //! Right multiply this->mat with m2.mat.
        constexpr mat44<F> operator* (const mat44<F>& m2) const noexcept
        {
            mat44<F> m;
            // Top row
            m.mat[0] = this->mat[0] * m2.mat[0] + this->mat[4] * m2.mat[1] + this->mat[8] * m2.mat[2] + this->mat[12] * m2.mat[3];
            m.mat[4] = this->mat[0] * m2.mat[4] + this->mat[4] * m2.mat[5] + this->mat[8] * m2.mat[6] + this->mat[12] * m2.mat[7];
            m.mat[8] = this->mat[0] * m2.mat[8] + this->mat[4] * m2.mat[9] + this->mat[8] * m2.mat[10] + this->mat[12] * m2.mat[11];
            m.mat[12] = this->mat[0] * m2.mat[12] + this->mat[4] * m2.mat[13] + this->mat[8] * m2.mat[14] + this->mat[12] * m2.mat[15];
            // Second row
            m.mat[1] = this->mat[1] * m2.mat[0] + this->mat[5] * m2.mat[1] + this->mat[9] * m2.mat[2] + this->mat[13] * m2.mat[3];
            m.mat[5] = this->mat[1] * m2.mat[4] + this->mat[5] * m2.mat[5] + this->mat[9] * m2.mat[6] + this->mat[13] * m2.mat[7];
            m.mat[9] = this->mat[1] * m2.mat[8] + this->mat[5] * m2.mat[9] + this->mat[9] * m2.mat[10] + this->mat[13] * m2.mat[11];
            m.mat[13] = this->mat[1] * m2.mat[12] + this->mat[5] * m2.mat[13] + this->mat[9] * m2.mat[14] + this->mat[13] * m2.mat[15];
            // Third row
            m.mat[2] = this->mat[2] * m2.mat[0] + this->mat[6] * m2.mat[1] + this->mat[10] * m2.mat[2] + this->mat[14] * m2.mat[3];
            m.mat[6] = this->mat[2] * m2.mat[4] + this->mat[6] * m2.mat[5] + this->mat[10] * m2.mat[6] + this->mat[14] * m2.mat[7];
            m.mat[10] = this->mat[2] * m2.mat[8] + this->mat[6] * m2.mat[9] + this->mat[10] * m2.mat[10] + this->mat[14] * m2.mat[11];
            m.mat[14] = this->mat[2] * m2.mat[12] + this->mat[6] * m2.mat[13] + this->mat[10] * m2.mat[14] + this->mat[14] * m2.mat[15];
            // Bottom row
            m.mat[3] = this->mat[3] * m2.mat[0] + this->mat[7] * m2.mat[1] + this->mat[11] * m2.mat[2] + this->mat[15] * m2.mat[3];
            m.mat[7] = this->mat[3] * m2.mat[4] + this->mat[7] * m2.mat[5] + this->mat[11] * m2.mat[6] + this->mat[15] * m2.mat[7];
            m.mat[11] = this->mat[3] * m2.mat[8] + this->mat[7] * m2.mat[9] + this->mat[11] * m2.mat[10] + this->mat[15] * m2.mat[11];
            m.mat[15] = this->mat[3] * m2.mat[12] + this->mat[7] * m2.mat[13] + this->mat[11] * m2.mat[14] + this->mat[15] * m2.mat[15];

            return m;
        }

        //! Do matrix times vector multiplication, v = mat * v1
        constexpr std::array<F, 4> operator* (const std::array<F, 4>& v1) const noexcept
        {
            std::array<F, 4> v;
            v[0] = this->mat[0] * v1[0] + this->mat[4] * v1[1] + this->mat[8] * v1[2] + this->mat[12] * v1[3];
            v[1] = this->mat[1] * v1[0] + this->mat[5] * v1[1] + this->mat[9] * v1[2] + this->mat[13] * v1[3];
            v[2] = this->mat[2] * v1[0] + this->mat[6] * v1[1] + this->mat[10] * v1[2] + this->mat[14] * v1[3];
            v[3] = this->mat[3] * v1[0] + this->mat[7] * v1[1] + this->mat[11] * v1[2] + this->mat[15] * v1[3];
            return v;
        }

        //! Do matrix times vector multiplication, v = mat * v1
        constexpr sm::vec<F, 4> operator* (const sm::vec<F, 4>& v1) const noexcept
        {
            sm::vec<F, 4> v;
            v[0] = this->mat[0] * v1.x() + this->mat[4] * v1.y() + this->mat[8] * v1.z() + this->mat[12] * v1.w();
            v[1] = this->mat[1] * v1.x() + this->mat[5] * v1.y() + this->mat[9] * v1.z() + this->mat[13] * v1.w();
            v[2] = this->mat[2] * v1.x() + this->mat[6] * v1.y() + this->mat[10] * v1.z() + this->mat[14] * v1.w();
            v[3] = this->mat[3] * v1.x() + this->mat[7] * v1.y() + this->mat[11] * v1.z() + this->mat[15] * v1.w();
            return v;
        }

        //! Do matrix times vector multiplication, v = mat * v1.
        constexpr sm::vec<F, 4> operator* (const sm::vec<F, 3>& v1) const noexcept
        {
            sm::vec<F, 4> v;
            v[0] = this->mat[0] * v1.x() + this->mat[4] * v1.y() + this->mat[8] * v1.z() + this->mat[12];
            v[1] = this->mat[1] * v1.x() + this->mat[5] * v1.y() + this->mat[9] * v1.z() + this->mat[13];
            v[2] = this->mat[2] * v1.x() + this->mat[6] * v1.y() + this->mat[10] * v1.z() + this->mat[14];
            v[3] = this->mat[3] * v1.x() + this->mat[7] * v1.y() + this->mat[11] * v1.z() + this->mat[15];
            return v;
        }

        //! *= operator for a scalar value.
        template <typename T=F> requires std::is_arithmetic_v<T>
        constexpr void operator*= (const T& f) noexcept
        {
            for (unsigned int i = 0; i<16; ++i) { this->mat[i] *= f; }
        }

        //! Equality operator. True if all elements match
        constexpr bool operator== (const mat44<F>& rhs) const noexcept
        {
            unsigned int ndiff = 0;
            for (unsigned int i = 0; i < 16 && ndiff == 0; ++i) {
                ndiff += this->mat[i] == rhs.mat[i] ? 0 : 1;
            }
            return ndiff == 0;
        }

        //! Not equals
        constexpr bool operator!= (const mat44<F>& rhs) const noexcept
        {
            unsigned int ndiff = 0;
            for (unsigned int i = 0; i < 16 && ndiff == 0; ++i) {
                ndiff += this->mat[i] == rhs.mat[i] ? 0 : 1;
            }
            return ndiff > 0;
        }

        //! Transpose this matrix
        constexpr void transpose_inplace() noexcept
        {
            std::array<F, 6> a;
            a[0] = this->mat[4];
            a[1] = this->mat[8];
            a[2] = this->mat[9];
            a[3] = this->mat[12];
            a[4] = this->mat[13];
            a[5] = this->mat[14];

            this->mat[4] = this->mat[1];
            this->mat[8] = this->mat[2];
            this->mat[9] = this->mat[6];
            this->mat[12] = this->mat[3];
            this->mat[13] = this->mat[7];
            this->mat[14] = this->mat[11];

            this->mat[1] = a[0];  // mat[4]
            this->mat[2] = a[1];  // mat[8]
            this->mat[3] = a[3];  // mat[12]
            this->mat[6] = a[2];  // mat[9]
            this->mat[7] = a[4];  // mat[13]
            this->mat[11] = a[5]; // mat[14]
        }

        //! Return the matrix transposed
        constexpr mat44<F> transpose() noexcept
        {
            mat44<F> m = *this;
            std::array<F, 6> a;
            a[0] = this->mat[4];
            a[1] = this->mat[8];
            a[2] = this->mat[9];
            a[3] = this->mat[12];
            a[4] = this->mat[13];
            a[5] = this->mat[14];

            m[4] = this->mat[1];
            m[8] = this->mat[2];
            m[9] = this->mat[6];
            m[12] = this->mat[3];
            m[13] = this->mat[7];
            m[14] = this->mat[11];

            m[1] = a[0];  // mat[4]
            m[2] = a[1];  // mat[8]
            m[3] = a[3];  // mat[12]
            m[6] = a[2];  // mat[9]
            m[7] = a[4];  // mat[13]
            m[11] = a[5]; // mat[14]

            return m;
        }

        //! Transpose the matrix @cm, returning the transposed version.
        static constexpr std::array<F, 16> transpose (const std::array<F, 16>& cm) noexcept
        {
            std::array<F, 16> m;
            m[0] = cm[0];
            m[4] = cm[1];
            m[8] = cm[2];
            m[12] = cm[3];
            m[1] = cm[4];
            m[5] = cm[5];
            m[9] = cm[6];
            m[13] = cm[7];
            m[2] = cm[8];
            m[6] = cm[9];
            m[10] = cm[10];
            m[14] = cm[11];
            m[3] = cm[12];
            m[7] = cm[13];
            m[11] = cm[14];
            m[15] = cm[15];
            return m;
        }

        /*!
         * Make a (frustrum) perspective projection in this matrix
         *
         * @fovDeg Field of view, in degrees. Measured from the top of the field to
         * the bottom of the field (rather than from the left to the right).
         *
         * @aspect The field's aspect ratio. For a field which is wider than it is
         * high, this will be >1. That is, this is "the number of multiples of the
         * height that the width is"
         *
         * @zNear The near/projection plane.
         *
         * @zFar The far plane.
         */
        constexpr void perspective_inplace (F fovDeg, F aspect, F zNear, F zFar) noexcept
        {
            (*this) = sm::mat44<F>::perspective (fovDeg, aspect, zNear, zFar);
        }

        /*!
         * Make a (frustrum) perspective projection
         *
         * @fovDeg Field of view, in degrees. Measured from the top of the field to
         * the bottom of the field (rather than from the left to the right).
         *
         * @aspect The field's aspect ratio. For a field which is wider than it is
         * high, this will be >1. That is, this is "the number of multiples of the
         * height that the width is"
         *
         * @zNear The near/projection plane.
         *
         * @zFar The far plane.
         *
         * \return the perspective projection matrix
         */
        static constexpr sm::mat44<F> perspective (F fovDeg, F aspect, F zNear, F zFar) noexcept
        {
            sm::mat44<F> m;

            // Bail out if the projection volume is zero-sized.
            if (zNear == zFar || aspect == F{0}) { return m; }

            F fovRad_ov2 = fovDeg * sm::mathconst<F>::pi_over_360; // fovDeg/2 converted to radians
            F sineFov = sm::cem::sin (fovRad_ov2);
            if (sineFov == F{0}) { return m; }
            F cotanFov = sm::cem::cos (fovRad_ov2) / sineFov;
            F clip = zFar - zNear;

            // Build perspective matrix
            m.mat.fill (F{0});
            m.mat[0] = cotanFov / aspect; // n/(width/2) = 2n/width, or generally 2n/r-l
            m.mat[5] = cotanFov;          // n/(height/2) = 2n/height, or generally 2n/t-b
            // For fully general frustrum not centered on the z axis, we would add these:
            //m.mat[8] = r+l/r-l
            //m.mat[9] = t+b/t-b
            m.mat[10] = -(zNear + zFar) / clip;
            m.mat[11] = F{-1};
            m.mat[14] = -(F{2} * zNear * zFar) / clip;

            return m;
        }

        /*!
         * Make an orthographic projection into this matrix
         *
         * \param rt Right-top coordinate. rt[0] is 'x' and thus the right and rt[1] ('y') is the top
         *
         * \param lb Left-bottom coordinate. lb[0] is 'x' and thus the left and lb[1] 'y' and is the bottom
         *
         * \param zFar The 'far' z coordinate of the canonical viewing volume
         *
         * \param zNear The 'near' z coordinate of the canonical viewing volume
         */
        constexpr void orthographic_inplace (const sm::vec<F, 2>& lb, const sm::vec<F, 2>& rt,
                                             const F zNear, const F zFar) noexcept
        {
            (*this) = sm::mat44<F>::orthographic (lb, rt, zNear, zFar);
        }

        /*!
         * Make an orthographic projection, returning as mat44
         *
         * \param rt Right-top coordinate. rt[0] is 'x' and thus the right and rt[1] ('y') is the top
         *
         * \param lb Left-bottom coordinate. lb[0] is 'x' and thus the left and lb[1] 'y' and is the bottom
         *
         * \param zFar The 'far' z coordinate of the canonical viewing volume
         *
         * \param zNear The 'near' z coordinate of the canonical viewing volume
         */
        static constexpr sm::mat44<F> orthographic (const sm::vec<F, 2>& lb, const sm::vec<F, 2>& rt,
                                                    const F zNear, const F zFar) noexcept
        {
            sm::mat44<F> m;

            if (zNear == zFar) { return m; }

            // Build orthographic matrix
            m.mat.fill (F{0});
            m.mat[0] = F{2} / (rt[0] - lb[0]);              //      2/(r-l)
            m.mat[5] = F{2} / (rt[1] - lb[1]);              //      2/(t-b)
            m.mat[10] = F{-2} / (zFar - zNear);             //     -2/(f-n)
            m.mat[12] = -(rt[0] + lb[0]) / (rt[0] - lb[0]); // -(r+l)/(r-l)
            m.mat[13] = -(rt[1] + lb[1]) / (rt[1] - lb[1]); // -(t+b)/(t-b)
            m.mat[14] = -(zFar + zNear) / (zFar - zNear);   // -(f+n)/(f-n)
            m.mat[15] = F{1};

            return m;
        }

        //! Overload the stream output operator
        friend std::ostream& operator<< <F> (std::ostream& os, const mat44<F>& tm);
    };

    template <typename F>
    std::ostream& operator<< (std::ostream& os, const mat44<F>& tm)
    {
        os << tm.str();
        return os;
    }

} // namespace sm
